import ballerina/grpc;
import ballerina/crypto;
import ballerina/log;
import ballerina/io;

listener grpc:Listener ep = new (9090);

map <recordInfo> Songs = {};

service recordsService on ep {

    resource function writeRecord(grpc:Caller caller, recordInfo value) {
        // Implementation goes here.
        byte[] hash = [];
        byte[] data = [];
        
        
        if(Songs.hasKey(value.toString())){
            string message = "Error, this song already exists in record";
			error? result = caller->send(message);
        }else{
            Songs[value.toString()] = <@untainted> value; 
            
            
        data = value.toString().toBytes();
        hash = crypto:hashSha384(data);
        
        io:println("Encryption with sha384: " + hash.toBase16());

            grpc:Error? result = caller->send(hash.toBase16());

            if(result is grpc:Error){
                log:printError("HashCode failed because " + result.reason().toString());
                
                result = caller->complete();
            }else{
                value.key = hash.toBase16();
            }
        }// You should return a hashCode
    }
    resource function updateRecord(grpc:Caller caller, hashCode value) {
        // Implementation goes here.
        map<json> |error recordInfo = map<json>.constructFrom(value);

        var response = caller ->send("Data received");
        if(response is grpc:Error){
            
            io:println("Error from client");
        }
        response = caller->complete();
        if(response is grpc:Error){

            io:println("Error from server");
        }
        

				io:println("****************** New Records ******************");
				io:println("Key          : ", value.key);
				io:println("Date         : ", value["date"];
				io:println("Artists      : ", value.artists);
                io:println("Tracks       : ", value.songs);
				io:println("Band         : ", value.band);
		// You should return a recordInfo
    }
        
    
    resource function readRecord(grpc:Caller caller, hashCode value) {
        // Implementation goes here.

        // You should return a recordInfo
    }
}

public type Tracks record {|
    string title = "";
    string genre = "";
    string platform = "";
    
|};

public type Artists record {|
    string name = "";
    string member = "";
    
|};

public type recordInfo record {|
    string key = "";
    string date = "";
    Artists[] artists = [];
    string band = "";
    Tracks[] songs = [];
    
|};

public type hashCode record {|
    string key = "";
    
|};



const string ROOT_DESCRIPTOR = "0A0D7265636F7264732E70726F746F12077365727669636522500A06547261636B7312140A057469746C6518012001280952057469746C6512140A0567656E7265180220012809520567656E7265121A0A08706C6174666F726D1803200128095208706C6174666F726D22350A074172746973747312120A046E616D6518012001280952046E616D6512160A066D656D62657218022001280952066D656D6265722299010A0A7265636F7264496E666F12100A036B657918012001280952036B657912120A0464617465180220012809520464617465122A0A076172746973747318032003280B32102E736572766963652E4172746973747352076172746973747312120A0462616E64180420012809520462616E6412250A05736F6E677318052003280B320F2E736572766963652E547261636B735205736F6E6773221C0A0868617368436F646512100A036B657918012001280952036B657932B5010A0E7265636F7264735365727669636512350A0B77726974655265636F726412132E736572766963652E7265636F7264496E666F1A112E736572766963652E68617368436F646512360A0C7570646174655265636F726412112E736572766963652E68617368436F64651A132E736572766963652E7265636F7264496E666F12340A0A726561645265636F726412112E736572766963652E68617368436F64651A132E736572766963652E7265636F7264496E666F620670726F746F33";
function getDescriptorMap() returns map<string> {
    return {
        "records.proto":"0A0D7265636F7264732E70726F746F12077365727669636522500A06547261636B7312140A057469746C6518012001280952057469746C6512140A0567656E7265180220012809520567656E7265121A0A08706C6174666F726D1803200128095208706C6174666F726D22350A074172746973747312120A046E616D6518012001280952046E616D6512160A066D656D62657218022001280952066D656D6265722299010A0A7265636F7264496E666F12100A036B657918012001280952036B657912120A0464617465180220012809520464617465122A0A076172746973747318032003280B32102E736572766963652E4172746973747352076172746973747312120A0462616E64180420012809520462616E6412250A05736F6E677318052003280B320F2E736572766963652E547261636B735205736F6E6773221C0A0868617368436F646512100A036B657918012001280952036B657932B5010A0E7265636F7264735365727669636512350A0B77726974655265636F726412132E736572766963652E7265636F7264496E666F1A112E736572766963652E68617368436F646512360A0C7570646174655265636F726412112E736572766963652E68617368436F64651A132E736572766963652E7265636F7264496E666F12340A0A726561645265636F726412112E736572766963652E68617368436F64651A132E736572766963652E7265636F7264496E666F620670726F746F33"
        
    };
}

*******************
import ballerina/io;
public function main (string... args) {

    recordsServiceClient blockingEp = new("http://localhost:9090");

        if (mode == "addSong") {
        recordInfo info = {
                date: "22/10/2020",
                artists: [
                    {
                    name: "Winston Marshall",
                    member: "yes"
                    },
                    {
                    name: "Ben Lovett",
                    member: "yes"
                    },
                    {
                    name: "Baaba Maal",
                    member: "no"
                    }
                ],
                band: "Mumford & Sons",
                songs: [
                    {
                        title: "There will be time",
                        genre: "folk rock",
                        platform: "Deezer"
                    }
                ]
            };

            [hashCode, grpc:Headers] result = check blockingEp->writeRecord(info);
            io:println("The record has been added successfully");
			io:println("HASH KEY : ",result);

    } else if (mode == "updateSong") {
    } else if (mode == "readSong") {
    } else {
        io:println("Operation unsupported! ");
        return;
    }

}

***********